[
{
	"uri": "http://vankesse-it.io/real_doc/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction REAL REAL enables developers to focus on business functionality, while retaining the breadth and power of the Java eco-system.\n"
},
{
	"uri": "http://vankesse-it.io/real_doc/domain/",
	"title": "Domain",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Domain Lorem Ipsum.\n"
},
{
	"uri": "http://vankesse-it.io/real_doc/domain/valuetype/boolean/",
	"title": "Boolean",
	"tags": [],
	"description": "",
	"content": "Create the Boolean value type by extending \u0026lsquo;DomainBoolean\u0026rsquo;.\nclass OrderConfirmed extends DomainBoolean{ public OrderConfirmed(final Boolean value) { super(value); } }"
},
{
	"uri": "http://vankesse-it.io/real_doc/domain/valuetype/decimal/",
	"title": "Decimal",
	"tags": [],
	"description": "",
	"content": " Decimal Value Types extend DomainDecimal, which is a wrapper arround a BigDecimal object. The constructor requires a meta-object MDecimal to specify precision, scale and rounding.\nThe decimal value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;add\u0026rsquo;, \u0026lsquo;subtract\u0026rsquo;, etc.\nFor example, the declaration of a new Amount value type with a precision of ten digits, and a scale of two:\npublic class Amount extends DomainDecimal\u0026lt;Amount\u0026gt; { public Amount(final BigDecimal value) { super(MDecimal.create(5, 2, MRounding.HALF_UP), value); } @Override protected Amount createInstance(final BigDecimal value) { return new Amount(value); } } Scale Domain decimals are rounded upon creation to ensure that no invalid objects can exist.\nSystem.out.println(\u0026#34;Scale:\u0026#34;); System.out.println(\u0026#34;- increase from 0 to 0.00 : \u0026#34; + new Amount(BigDecimal.ZERO)); System.out.println(\u0026#34;- increase from 1 to 1.00 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1\u0026#34;))); System.out.println(\u0026#34;- increase from 1.2 to 1.20 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.2\u0026#34;))); System.out.println(\u0026#34;- valid amount 1.23 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.23\u0026#34;))); System.out.println(\u0026#34;- round down from 1.233 to 1.23: \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.233\u0026#34;))); System.out.println(\u0026#34;- round up from 1.237 to 1.24: \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.237\u0026#34;))); result:\nScale: - increase from 0 to 0.00 : 0.00 - increase from 1 to 1.00 : 1.00 - increase from 1.2 to 1.20 : 1.20 - valid amount 1.23 : 1.23 - round down from 1.233 to 1.23: 1.23 - round up from 1.237 to 1.24: 1.24  Precision System.out.println(\u0026quot;Decrease precision:\u0026quot;); System.out.println(\u0026quot;- from 12345.67 to 12346.00: \u0026quot; + new Amount(new BigDecimal(\u0026quot;12345.67\u0026quot;))); System.out.println(\u0026quot;- from 123456789 to 123460000.00: \u0026quot; + new Amount(new BigDecimal(\u0026quot;123456789\u0026quot;)));  result:\nDecrease precision: - from 12345.67 to 12346.00: 12346.00 - from 123456789 to 123460000.00: 123460000.00  Usage REAL will generate Value Type classes with many extra methods and constructors, but for this example we will add some of these methods manually.\nFirst a new constructor for Amount to create new instances based on other decimals:\npublic Amount(final DomainDecimal\u0026lt;?\u0026gt; value) { this(value.getValue()); } and two new Decimal types, Quantity:\nclass Quantity extends DomainDecimal\u0026lt;Quantity\u0026gt; { public Quantity(final BigDecimal value) { super(MDecimal.create(5, 2, MRounding.HALF_UP), value); } @Override protected Quantity createInstance(final BigDecimal value) { return new Quantity(value); } } and Price:\nclass Price extends DomainDecimal\u0026lt;Price\u0026gt; { public Price(final BigDecimal value) { super(MDecimal.create(5, 3, MRounding.HALF_UP), value); } @Override protected Price createInstance(final BigDecimal value) { return new Price(value); } public Amount multiply(final Quantity quantity) { return new Amount(super.multiply(quantity)); } } Value Types are plain java classes and can be extended with extra functionality, like the multiply method in the Price class. This method takes a quantity, multiplies it with the price and returns an amount using the new amount-constructor.\nGiven these new value types, calculations are possible using only the business concepts Amount, Price and Quantity:\n@Test public void priceExample() { final Price price = new Price(new BigDecimal(\u0026#34;13.3329\u0026#34;)); final Quantity quantity = new Quantity(new BigDecimal(\u0026#34;3.50\u0026#34;)); final Amount amount = price.multiply(quantity); System.out.println(\u0026#34;Price \u0026#34;+price); System.out.println(\u0026#34;Quantity * \u0026#34;+quantity); System.out.println(\u0026#34;Amount = \u0026#34;+amount); } result:\nPrice 13.333 Quantity * 3.50 Amount = 46.67  It is important to notice that two roundings were applied. The price is rounded to 13.333 before calculation. And after multiplication the result is rounded from 46.6655 to 46.67.\nAutomatic rounding must be used with care as a loss of precision can result in imprecise results.\n Validation Value Types can be validated by adding checks in the constructor. For example, disallow negative prices:\npublic Price(final BigDecimal value) { super(MDecimal.create(5, 3, MRounding.HALF_UP), value); if(isNegative()) { throw DomainValueException.create(\u0026#34;Negative price not allowed: \u0026#34;+this); } } This will cause an exception in all business logic whenever a negative price is created.\nnew Price(new BigDecimal(\u0026#34;-3.59\u0026#34;)); result:\nnl.openframe.domain.value.DomainValueException: Negative price not allowed: -3.590  Convenience methods Besides the standard methods add, substract, multiply, divide, max and min, domain decimals include additional convenience methods:\nfinal Amount amount = new Amount(new BigDecimal(\u0026#34;1.23\u0026#34;)); System.out.println(\u0026#34;absolute : \u0026#34;+ amount.absolute()); System.out.println(\u0026#34;negate : \u0026#34;+ amount.negate()); System.out.println(\u0026#34;is-negative : \u0026#34;+ amount.isNegative()); System.out.println(\u0026#34;is-positive : \u0026#34;+ amount.isPositive()); System.out.println(\u0026#34;is-zero : \u0026#34;+ amount.isZero()); System.out.println(\u0026#34;is-non-zero : \u0026#34;+ amount.isNonZero()); System.out.println(\u0026#34;is-one : \u0026#34;+ amount.isOne()); System.out.println(\u0026#34;is-minus one: \u0026#34;+ amount.isNegativeOne()); result:\nabsolute : 1.23 negate : -1.23 is-negative : false is-positive : true is-zero : false is-non-zero : true is-one : false is-minus one: false  "
},
{
	"uri": "http://vankesse-it.io/real_doc/introduction/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": " A set of 13 libraries "
},
{
	"uri": "http://vankesse-it.io/real_doc/domain/entity/",
	"title": "Entity",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankesse-it.io/real_doc/introduction/comparison/",
	"title": "Product Comparison",
	"tags": [],
	"description": "",
	"content": " How does it stack up ? REAL is a low-code software development environment. REAL aims to minimize the overall code-base of administrative systems, while promoting concise and quality business-code.\n    Thinkwise Mendix Studio Pro 8 REAL 7     General      Technologie Platform MS .NET Java 11 Java 11   Product Type framework framework set libraries (13 in total)   Programming language procedural SQL nano/micro-flows, Java/JS call-outs Java for desktop, web (mobile) and server   Target audience Thinkwise developers Citizen developers Professional developers   Since 2002 2005 2007   # Developers 20+ 20+ 2+   Modelling      Database grafical-model grafical-model text-model (Domain Specific Language)   User-interface definition in tabels UI-designer, pages / widgets text-model (DSL), code or UI-designer (Vaadin)   Custom Code      Business code works only within Thinkwise works only within Mendix (micro-flow) independent from REAL, standard Java / Spring   User-interface code programming not supported works only within Mendix (nano-flow) dependent on REAL, standard Java / Spring   Uitbreidbaarheid very limited limited Java/JS call-out complete Java / Spring platform, and external libraries   Code Quality      Automatic checks no no industry-standard: Sonar, Structure101, etc.   Automated testing ? proprietary (unit-test microflow) industry-standard: JUnit, etc.   Value Types yes (limited) no yes, e.g. Amount, Price, Document, Quantity, etc.   Nullability checks no no yes, avoid the \u0026ldquo;billion dollar mistake\u0026rdquo; (Tony Hoare)   Tooling      Development environment proprietary proprietary industry-standard: Eclipse of IntelliJ   Versiebeheer proprietary, code and model separat proprietary, SVN extension (Team Server) industry-standard (GIT), datamodel and code    Deployment proprietary proprietary (Mendix server) industry-standard: Tomcat, JBoss, Websphere, etc.   Monitoring Database or IIS monitoring Java JMX Spring Boot Actuator and Java JMX   Continuity      # developers very limited limited 10.000.000 according to Oracle   Business-code dependend on Thinkwise dependend on Mendix dependend on Java (open source)   *Vendor lock-in 100% 100% user-interface limited, business-code no lock-in   Escrow available ? yes yes    "
},
{
	"uri": "http://vankesse-it.io/real_doc/domain/valuetype/",
	"title": "Value types",
	"tags": [],
	"description": "",
	"content": "Value Types wrap Java primitive types in order to provide additional abstraction and validation.\nValue Types are immutable objects that represent business concepts which have no identity of their own. They are identified by the object properties, the same as for instance a String object in Java.\nExamples of Value Types are Amount, Price, Quantity and Confirmed.\nREAL will only create valid Value Types in order to prevent runtime errors.\n -- REAL will ensure that only valid value-type-objects can be created. This can mean that numeric values are rounded upon creation, or an exception is thrown in case of a String that exeeds the maximum length.\nThe following value types are supported:\n Boolean Date DateTime Decimal Enumerate Integer Long String Text Time  All value types implement the Comparable interface consistent and provide a getValue() method for retrieving the wrapped primitive value.\n"
},
{
	"uri": "http://vankesse-it.io/real_doc/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankesse-it.io/real_doc/",
	"title": "REAL ERP",
	"tags": [],
	"description": "",
	"content": " REAL Documentation REAL Documentation is created with Hugo and Hugo-theme-learn, a fast and modern static website engine written in Go.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it\nYour modification will be deployed automatically when merged.\n Automatically published and hosted thanks to Netlify. Read more about Automated HUGO deployments with Netlify\n -- "
},
{
	"uri": "http://vankesse-it.io/real_doc/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]