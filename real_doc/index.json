[
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/",
	"title": "Value types",
	"tags": [],
	"description": "",
	"content": " Value Types are immutable objects that represent business concepts which have no identity of their own. They are identified by the object properties, the same as for instance a String object in Java. Examples of Value Types are Amount, Price, Quantity and Confirmed.\nValue Types wrap Java primitive types in order to provide additional abstraction and validation. The following value types are supported:\n Boolean Date DateTime Decimal Enumerate Integer Long String Text Time  Abstraction Value Types make business code more readable and concise. Consider, for example, the following createOrder method:\npublic SalesOrder createOrder( Document document, OrderDate orderDate, Customer customer, Reference customerReference, Item item, Quantity quantity, Price price) It is very specific regarding the input parameters. The caller has to provide a Document which will be defined as a string, of a specific length and without spaces. The Reference is a much longer string and does allow spaces. The OrderDate is defined to be different from an InvoiceDate. The Quantity has a smaller scale than Price. Et cetera\u0026hellip;\nCompare this with the same method without value type abstaction:\npublic SalesOrder createOrder( String document, LocalDate orderDate, Customer customer, String customerReference, Item item, BigDecimal quantity, BigDecimal price) Much of the semantics are lost. Furthermore, this method with primitive parameters allows the quantity and price to be mixed up. It accepts documents that might be too long for the database, or might contain spaces. Et cetera\u0026hellip;(often used in conjunction with Boris Johnson)\nValidation Only valid value-type instances can be created. Decimals are rounded upon creation to fit the precision and scale. String value types will throw an exception upon creation if they exceed the defined length.\nFurthermore, as value-types are classes, new validation logic can be added in the constructor.\nAll value types implement the Comparable interface and provide a getValue() method to access the wrapped primitive value.\n Java versus DSL Value Types can be created by extending the base classes: DomainBoolean, DomainDate, DomainDateTime, DomainDecimal, DomainEnumerate, DomainInteger, DomainLong, DomainString, DomainText and DomainTime.\nThe REAL DSL however provides a more convenient way, and includes a default label-code that can be used in entities and views. The DSL declaration generates all required Java classes and adds additonal static constructors.\nboolean Confirmed confirmedLabel date ExecutionDate executionDateLabel datetime DataEntryDateTime dataEntryDateTimeLabel milliseconds decimal Amount amountLabel 10 2 half_up integer IPPort ipPortLabel 0 99999 long EventId eventIdLabel 0 999999999 string Description descriptionLabel 60 text Notes notesLabel time BatchTime batchTimeLabel minutes  Note that the Enumerate Value Type must be created using the DSL for the simple reason that Enumerates in Java do not support inheritance.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction REAL enables developers to focus on business functionality, while retaining the breadth and power of the Java eco-system.\n"
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/entity/",
	"title": "Entity",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/",
	"title": "Domain",
	"tags": [],
	"description": "",
	"content": " Domain "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/boolean/",
	"title": "Boolean",
	"tags": [],
	"description": "",
	"content": " Java Boolean Value Types extend DomainBoolean, which is a wrapper arround a Boolean instance.\nThe value-type must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;negate\u0026rsquo;.\nFor example, the declaration of a new Confirmed value type:\nclass Confirmed extends DomainBoolean\u0026lt;Confirmed\u0026gt;{ public Confirmed(final Boolean value) { super(value); } @Override protected Confirmed createInstance(final Boolean value) { return new Confirmed(value); } } usage:\nfinal Confirmed confirmed = new Confirmed(false); System.out.println(\u0026#34;negate : \u0026#34; +confirmed.negate()); System.out.println(\u0026#34;is-false : \u0026#34; +confirmed.isFalse()); System.out.println(\u0026#34;is-true : \u0026#34; +confirmed.isTrue()); result:\nnegate : true is-false : true is-true : false  DSL Boolean value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.SystemLabels.confirmedLabel boolean Confirmed confirmedLabel  This will generate two new classes: Confirmed.java and AbstractConfirmed.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class Confirmed extends AbstractConfirmed{ public Confirmed(final Boolean value) { super(value); } } The abstract class extends DomainBoolean and adds several new static constructors:\nfinal Confirmed c1 = Confirmed.valueOf(true); final Confirmed c2 = Confirmed.valueOf(\u0026#34;True\u0026#34;); final Confirmed c3 = Confirmed.valueOf(\u0026#34;T\u0026#34;); // Equality is based on the underlying Boolean value. System.out.println(\u0026#34;c1.equal(c2) : \u0026#34; + c1.equals(c2)); System.out.println(\u0026#34;c1.equal(c3) : \u0026#34; + c1.equals(c3)); result:\nc1.equal(c2) : true c1.equal(c3) : true  "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/date/",
	"title": "Date",
	"tags": [],
	"description": "",
	"content": " Java Date Value Types extend DomainDate, which is a wrapper arround a LocalDate instance.\nThe Date value-type class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;plusDays\u0026rsquo; and \u0026lsquo;minusDays\u0026rsquo;.\nFor example, the declaration of a new InvoiceDate type:\nclass InvoiceDate extends DomainDate\u0026lt;InvoiceDate\u0026gt;{ public InvoiceDate(final LocalDate value) { super(value); } @Override protected InvoiceDate createInstance(final LocalDate value) { return new InvoiceDate(value); } } usage:\nfinal InvoiceDate d1 = new InvoiceDate(LocalDate.now()); final InvoiceDate d2 = d1.plusDays(5); final InvoiceDate d3 = d1.minusDays(5); System.out.println(\u0026#34;d1.plusDays(5) : \u0026#34; +d2); System.out.println(\u0026#34;d1.minusDays(5): \u0026#34; +d3); System.out.println(\u0026#34;d2.isBefore(d1): \u0026#34; +d2.isBefore(d1)); System.out.println(\u0026#34;d2.isAfter(d1) : \u0026#34; +d2.isAfter(d1)); System.out.println(\u0026#34;d2.equals(d1) : \u0026#34; +d2.equals(d1)); result:\nd1.plusDays(5) : 2019-08-27 d1.minusDays(5): 2019-08-17 d2.isBefore(d1): false d2.isAfter(d1) : true d2.equals(d1) : false  DSL Date value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.bt.SYS_BTLabels.executionDateLabel date ExecutionDate executionDateLabel  This will generate two new classes: ExecutionDate.java and AbstractExecutionDate.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class ExecutionDate extends AbstractExecutionDate{ public ExecutionDate(final LocalDate value) { super(value); } } The abstract class extends DomainDate and adds several new static constructors:\nfinal ExecutionDate d1 = ExecutionDate.now(); final ExecutionDate d2 = ExecutionDate.valueOf(LocalDate.now()); final ExecutionDate d3 = ExecutionDate.valueOf(\u0026#34;01-01-2019\u0026#34;); final ExecutionDate d4 = ExecutionDate.valueOf(d3.minusDays(1)); System.out.println(\u0026#34;d1 : \u0026#34; + d1); System.out.println(\u0026#34;d2 : \u0026#34; + d2); System.out.println(\u0026#34;d3 : \u0026#34; + d3); System.out.println(\u0026#34;d4 : \u0026#34; + d4); System.out.println(\u0026#34;d1.equals(d2) : \u0026#34; + d1.equals(d2)); System.out.println(\u0026#34;d1.equals(d3) : \u0026#34; + d1.equals(d3)); result:\nd1 : 22-08-2019 d2 : 22-08-2019 d3 : 01-01-2019 d4 : 31-12-2018 d1.equals(d2) : true d1.equals(d3) : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/datetime/",
	"title": "DateTime",
	"tags": [],
	"description": "",
	"content": " Java DateTime Value Types extend DomainDateTime, which is a wrapper arround a LocalDateTime instance. The constructor requires a meta-object MDateTime to specify the precision: minutes, seconds or milliseconds.\nThe DateTime value-type class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;plusDays\u0026rsquo; and \u0026lsquo;minusDays\u0026rsquo;.\nFor example, the declaration of a new TimeStamp type:\nclass TimeStamp extends DomainDateTime\u0026lt;TimeStamp\u0026gt;{ public TimeStamp(final LocalDateTime value) { super(MDateTime.create(MTimePrecision.MINUTES), value); } @Override protected TimeStamp createInstance(final LocalDateTime value) { return new TimeStamp(value); } } usage:\nfinal TimeStamp d1 = new TimeStamp(LocalDateTime.now()); final TimeStamp d2 = d1.plusMinutes(5); final TimeStamp d3 = d1.minusHours(5); final TimeStamp d4 = d1.plusSeconds(10); final TimeStamp d5 = d1.minusSeconds(20); System.out.println(\u0026#34;d1 : \u0026#34; +d1); System.out.println(\u0026#34;d1.plusMinutes(5) : \u0026#34; +d2); System.out.println(\u0026#34;d1.minusHours(5) : \u0026#34; +d3); System.out.println(\u0026#34;d1.plusSeconds(20) : \u0026#34; +d4); System.out.println(\u0026#34;d1.minusSeconds(20): \u0026#34; +d5); System.out.println(\u0026#34;d2.isBefore(d1) : \u0026#34; +d2.isBefore(d1)); System.out.println(\u0026#34;d2.isAfter(d1) : \u0026#34; +d2.isAfter(d1)); System.out.println(\u0026#34;d1.equals(d4) : \u0026#34; +d1.equals(d4)); System.out.println(\u0026#34;d1.equals(d5) : \u0026#34; +d1.equals(d5)); result:\nd1 : 2019-08-22T16:23 d1.plusMinutes(5) : 2019-08-22T16:28 d1.minusHours(5) : 2019-08-22T11:23 d1.plusSeconds(20) : 2019-08-22T16:23 d1.minusSeconds(20): 2019-08-22T16:22 d2.isBefore(d1) : false d2.isAfter(d1) : true d1.equals(d4) : true d1.equals(d5) : false  Notice that the results of plusSeconds() and minusSeconds() are truncated to minutes according to the precision of TimeStamp.\n DSL DateTime value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.sr.SYS_SRLabels.alertDateTimeLabel datetime AlertDateTime alertDateTimeLabel milliseconds  This will generate two new classes: AlertDateTime.java and AbstractAlertDateTime.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class AlertDateTime extends AbstractAlertDateTime{ public AlertDateTime(final LocalDateTime value) { super(value); } } The abstract class extends DomainDateTime and adds several new static constructors:\nfinal AlertDateTime d1 = AlertDateTime.now(); final AlertDateTime d2 = AlertDateTime.valueOf(LocalDateTime.now()); final AlertDateTime d3 = AlertDateTime.valueOf(\u0026#34;01-01-2019\u0026#34;); final AlertDateTime d4 = AlertDateTime.valueOf(d3.minusDays(1)); System.out.println(\u0026#34;d1 : \u0026#34; + d1); System.out.println(\u0026#34;d2 : \u0026#34; + d2); System.out.println(\u0026#34;d3 : \u0026#34; + d3); System.out.println(\u0026#34;d4 : \u0026#34; + d4); System.out.println(\u0026#34;d1.equals(d2) : \u0026#34; + d1.equals(d2)); System.out.println(\u0026#34;d1.equals(d3) : \u0026#34; + d1.equals(d3)); result:\nd1 : 22-08-2019 16:45:45.381191000 d2 : 22-08-2019 16:45:45.382224000 d3 : 01-01-2019 08:00:00.00 d4 : 31-12-2018 08:00:00.00 d1.equals(d2) : false d1.equals(d3) : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/decimal/",
	"title": "Decimal",
	"tags": [],
	"description": "",
	"content": " Java Decimal Value Types extend DomainDecimal, which is a wrapper arround a BigDecimal instance. The constructor requires a meta-object MDecimal to specify precision, scale and rounding.\nThe decimal value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;add\u0026rsquo;, \u0026lsquo;subtract\u0026rsquo;, etc.\nFor example, the declaration of a new Amount value type with a precision of five digits, and a scale of two:\npublic class Amount extends DomainDecimal\u0026lt;Amount\u0026gt; { public Amount(final BigDecimal value) { super(MDecimal.create(5, 2, MRounding.HALF_UP), value); } @Override protected Amount createInstance(final BigDecimal value) { return new Amount(value); } } Scale Domain decimals are rounded upon creation to ensure that no invalid objects can exist.\nSystem.out.println(\u0026#34;Scale:\u0026#34;); System.out.println(\u0026#34;- increase from 0 to 0.00 : \u0026#34; + new Amount(BigDecimal.ZERO)); System.out.println(\u0026#34;- increase from 1 to 1.00 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1\u0026#34;))); System.out.println(\u0026#34;- increase from 1.2 to 1.20 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.2\u0026#34;))); System.out.println(\u0026#34;- valid amount 1.23 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.23\u0026#34;))); System.out.println(\u0026#34;- round down from 1.233 to 1.23: \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.233\u0026#34;))); System.out.println(\u0026#34;- round up from 1.237 to 1.24: \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.237\u0026#34;))); result:\nScale: - increase from 0 to 0.00 : 0.00 - increase from 1 to 1.00 : 1.00 - increase from 1.2 to 1.20 : 1.20 - valid amount 1.23 : 1.23 - round down from 1.233 to 1.23: 1.23 - round up from 1.237 to 1.24: 1.24  Precision System.out.println(\u0026quot;Decrease precision:\u0026quot;); System.out.println(\u0026quot;- from 12345.67 to 12346.00: \u0026quot; + new Amount(new BigDecimal(\u0026quot;12345.67\u0026quot;))); System.out.println(\u0026quot;- from 123456789 to 123460000.00: \u0026quot; + new Amount(new BigDecimal(\u0026quot;123456789\u0026quot;)));  result:\nDecrease precision: - from 12345.67 to 12346.00: 12346.00 - from 123456789 to 123460000.00: 123460000.00  Usage REAL will generate Value Type classes with many extra methods and constructors, but for this example we will add some of these methods manually.\nFirst a new constructor for Amount to create new instances based on other decimals:\npublic Amount(final DomainDecimal\u0026lt;?\u0026gt; value) { this(value.getValue()); } and two new Decimal types, Quantity:\nclass Quantity extends DomainDecimal\u0026lt;Quantity\u0026gt; { public Quantity(final BigDecimal value) { super(MDecimal.create(5, 2, MRounding.HALF_UP), value); } @Override protected Quantity createInstance(final BigDecimal value) { return new Quantity(value); } } and Price:\nclass Price extends DomainDecimal\u0026lt;Price\u0026gt; { public Price(final BigDecimal value) { super(MDecimal.create(5, 3, MRounding.HALF_UP), value); } @Override protected Price createInstance(final BigDecimal value) { return new Price(value); } public Amount multiply(final Quantity quantity) { return new Amount(super.multiply(quantity)); } } Value Types are plain java classes and can be extended with extra functionality, like the multiply method in the Price class. This method takes a quantity, multiplies it with the price and returns an amount using the new amount-constructor.\nGiven these new value types, calculations are possible using only the business concepts Amount, Price and Quantity:\nfinal Price price = new Price(new BigDecimal(\u0026#34;13.3329\u0026#34;)); final Quantity quantity = new Quantity(new BigDecimal(\u0026#34;3.50\u0026#34;)); final Amount amount = price.multiply(quantity); System.out.println(\u0026#34;Price \u0026#34;+price); System.out.println(\u0026#34;Quantity * \u0026#34;+quantity); System.out.println(\u0026#34;Amount = \u0026#34;+amount); result:\nPrice 13.333 Quantity * 3.50 Amount = 46.67  It is important to notice that two roundings were applied. The price is rounded to 13.333 before calculation. And after multiplication the result is rounded from 46.6655 to 46.67.\nAutomatic rounding must be used with care as a loss of precision can result in imprecise results.\n Validation Value Types can be validated by adding checks in the constructor. For example, disallow negative prices:\npublic Price(final BigDecimal value) { super(MDecimal.create(5, 3, MRounding.HALF_UP), value); if(isNegative()) { throw DomainValueException.create(\u0026#34;Negative price not allowed: \u0026#34;+this); } } This will cause an exception in all business logic whenever a negative price is created.\nnew Price(new BigDecimal(\u0026#34;-3.59\u0026#34;)); result:\nnl.openframe.domain.value.DomainValueException: Negative price not allowed: -3.590  Convenience methods Besides the standard methods add, substract, multiply, divide, max and min, domain decimals include additional convenience methods:\nfinal Amount amount = new Amount(new BigDecimal(\u0026#34;1.23\u0026#34;)); System.out.println(\u0026#34;absolute : \u0026#34;+ amount.absolute()); System.out.println(\u0026#34;negate : \u0026#34;+ amount.negate()); System.out.println(\u0026#34;is-negative : \u0026#34;+ amount.isNegative()); System.out.println(\u0026#34;is-positive : \u0026#34;+ amount.isPositive()); System.out.println(\u0026#34;is-zero : \u0026#34;+ amount.isZero()); System.out.println(\u0026#34;is-non-zero : \u0026#34;+ amount.isNonZero()); System.out.println(\u0026#34;is-one : \u0026#34;+ amount.isOne()); System.out.println(\u0026#34;is-minus one: \u0026#34;+ amount.isNegativeOne()); result:\nabsolute : 1.23 negate : -1.23 is-negative : false is-positive : true is-zero : false is-non-zero : true is-one : false is-minus one: false  DSL Decimal value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.SystemLabels.amountLabel decimal Amount amountLabel 10 2 half_up  This will generate two new classes: Amount.java and AbstractAmount.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class Amount extends AbstractAmount{ public Amount(final BigDecimal value) { super(value); } } The abstract class extends DomainDecimal and adds several new static constructors:\n// Create new instance final Amount a1 = Amount.valueOf(new BigDecimal(\u0026#34;123.45\u0026#34;)); final Amount a2 = Amount.valueOf(123.45); final Amount a3 = Amount.valueOf(\u0026#34;123.45\u0026#34;); // Convert Amount to Price final Price p1 = Price.valueOf(a1); Because value types objects are immutable they can benefit from caching (\u0026lsquo;flyweight\u0026rsquo; design-pattern). This is enabled by using static constructors.\nEquality Domain Decimal equality is based on the underlying BigDecimal value.\nSystem.out.println(\u0026quot;a1.equal(a2) : \u0026quot; + a1.equals(a2)); System.out.println(\u0026quot;a1.equal(a3) : \u0026quot; + a1.equals(a3));  result:\na1.equal(a2) : true a1.equal(a3) : true  Only values with the same precision and scale can be equal.\n// Price and Amount have different scales System.out.println(\u0026quot;p1.equal(a1) : \u0026quot; + p1.equals(a1));  result:\np1.equal(a1) : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": " A set of 13 libraries "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/integer/",
	"title": "Integer / Long",
	"tags": [],
	"description": "",
	"content": " Java Note: Value type DomainLong is not described here as it works the same as DomainInteger, except for the larger number range.\n Integer Value Types extend DomainInteger, which is a wrapper arround a Integer instance. The constructor requires a meta-object MInteger to specify lower- and upper-limit.\nThe integer value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;append\u0026rsquo;.\nFor example, the declaration of a new PortNumber value type with a range of [0,65535].\nclass PortNumber extends DomainInteger\u0026lt;PortNumber\u0026gt;{ public PortNumber(final Integer value) { super(MInteger.create(0, 65535), value); } @Override protected PortNumber createInstance(final Integer value) { return new PortNumber(value); } } usage:\nfinal PortNumber d1 = new PortNumber(80); final PortNumber d2 = new PortNumber(8000); final PortNumber d3 = d1.add(d2); System.out.println(\u0026#34;d1 : \u0026#34; +d1); System.out.println(\u0026#34;d2 : \u0026#34; +d2); System.out.println(\u0026#34;d3 : \u0026#34; +d3); System.out.println(\u0026#34;d1.isNegative() : \u0026#34; +d1.isNegative()); System.out.println(\u0026#34;d1.isZero() : \u0026#34; +d1.isZero()); result:\nd1 : 80 d2 : 8000 d3 : 8080 d1.isNegative() : false d1.isZero() : false  Note that an exception is thrown if the value is not within the declared range:\nnew PortNumber(-1); result:\nDomainValueException: Value -1 exceeds minimum value 0.  DSL Integer value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.sr.SYS_SRLabels.batchFrequencyLabel integer BatchFrequency batchFrequencyLabel 0 60  This will generate two new classes: BatchFrequency.java and AbstractBatchFrequency.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class BatchFrequency extends AbstractBatchFrequency{ public BatchFrequency(final Integer value) { super(value); } } The abstract class extends DomainInteger and adds several new static constructors:\nfinal BatchFrequency n1 = BatchFrequency.ONE; final BatchFrequency n2 = BatchFrequency.valueOf(\u0026#34;1\u0026#34;); final BatchFrequency n3 = BatchFrequency.valueOf(1); final BatchFrequency n4 = BatchFrequency.valueOf(15); final BatchFrequency n5 = BatchFrequency.valueOf(4); System.out.println(\u0026#34;n1 : \u0026#34; + n1); System.out.println(\u0026#34;n2 : \u0026#34; + n2); System.out.println(\u0026#34;n3 : \u0026#34; + n3); System.out.println(\u0026#34;n4 : \u0026#34; + n4); System.out.println(\u0026#34;n5 : \u0026#34; + n5); System.out.println(\u0026#34;n4.divide(n5) : \u0026#34;+ n4.divide(n5)); System.out.println(\u0026#34;n4.multiply(n5): \u0026#34;+ n4.multiply(n5)); System.out.println(\u0026#34;n1.isOne() : \u0026#34;+ n1.isOne()); System.out.println(\u0026#34;n2.equal(n3) : \u0026#34;+ n2.equals(n3)); result:\nn1 : 1 n2 : 1 n3 : 1 n4 : 15 n5 : 4 n4.divide(n5) : 3 n4.multiply(n5): 60 n1.isOne() : true n2.equal(n3) : true  Notice that the results of divide() is truncated to an integer value.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/comparison/",
	"title": "Product Comparison",
	"tags": [],
	"description": "",
	"content": " How does it stack up ? REAL is a low-code software development environment. REAL aims to minimize the overall code-base of administrative systems, while promoting concise and quality business-code.\n    Thinkwise Mendix Studio Pro 8 REAL 7     General      Technologie Platform MS .NET Java 11 Java 11   Product Type framework framework set libraries (13 in total)   Programming language procedural SQL nano/micro-flows, Java/JS call-outs Java for desktop, web (mobile) and server   Target audience Thinkwise developers Citizen developers Professional developers   Since 2002 2005 2007   # Developers 20+ 20+ 2+   Modelling      Database grafical-model grafical-model text-model (Domain Specific Language)   User-interface definition in tabels UI-designer, pages / widgets text-model (DSL), code or UI-designer (Vaadin)   Custom Code      Business code works only within Thinkwise works only within Mendix (micro-flow) independent from REAL, standard Java / Spring   User-interface code programming not supported works only within Mendix (nano-flow) dependent on REAL, standard Java / Spring   Uitbreidbaarheid very limited limited Java/JS call-out complete Java / Spring platform, and external libraries   Code Quality      Automatic checks no no industry-standard: Sonar, Structure101, etc.   Automated testing ? proprietary (unit-test microflow) industry-standard: JUnit, etc.   Value Types yes (limited) no yes, e.g. Amount, Price, Document, Quantity, etc.   Nullability checks no no yes, avoid the \u0026ldquo;billion dollar mistake\u0026rdquo; (Tony Hoare)   Tooling      Development environment proprietary proprietary industry-standard: Eclipse of IntelliJ   Versiebeheer proprietary, code and model separat proprietary, SVN extension (Team Server) industry-standard (GIT), datamodel and code    Deployment proprietary proprietary (Mendix server) industry-standard: Tomcat, JBoss, Websphere, etc.   Monitoring Database or IIS monitoring Java JMX Spring Boot Actuator and Java JMX   Continuity      # developers very limited limited 10.000.000 according to Oracle   Business-code dependend on Thinkwise dependend on Mendix dependend on Java (open source)   *Vendor lock-in 100% 100% user-interface limited, business-code no lock-in   Escrow available ? yes yes    "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/string/",
	"title": "String / Text",
	"tags": [],
	"description": "",
	"content": " Java Note: Value type DomainText is not described here as it works the same as DomainString, except for the limitless text length.\n String Value Types extend DomainString, which is a wrapper arround a String instance. The constructor requires a meta-object MString to specify length and case.\nThe string value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;append\u0026rsquo;.\nFor example, the declaration of a new Description value type with a lenght of 60 characters.\nclass Description extends DomainString\u0026lt;Description\u0026gt;{ public Description(final String value) { super(MString.create(60, false), value); } @Override protected Description createInstance(final String value) { return new Description(value); } } usage:\nfinal Description d1 = new Description(\u0026#34;abcdefg\u0026#34;); System.out.println(\u0026#34;d1.append(\u0026#39;_hij\u0026#39;): \u0026#34; +d1.append(\u0026#34;_hij\u0026#34;)); System.out.println(\u0026#34;getLeft(3) : \u0026#34; +d1.getLeft(3)); System.out.println(\u0026#34;isEmpty() : \u0026#34; +d1.isEmpty()); System.out.println(\u0026#34;isNotEmpty() : \u0026#34; +d1.isNotEmpty()); result:\nd1.append('_hij'): abcdefg_hij getLeft(3) : abc isEmpty() : false isNotEmpty() : true  Note that strings are not automatically truncated, if they do not fit the domain, an exception will be thrown:\nnew Description(\u0026#34;abcdefg\u0026#34;.repeat(30)); result:\nDomainValueException: Value exceeds 60 characters.  DSL String value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.SystemLabels.descriptionLabel string Description descriptionLabel 60  This will generate two new classes: Description.java and AbstractDescription.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class Description extends AbstractDescription{ public Description(final String value) { super(value); } } The abstract class extends DomainString and adds several new static constructors:\nfinal Name n1 = Name.valueOf(\u0026#34;abcdef\u0026#34;); final Description d1 = Description.valueOf(\u0026#34;abcdef\u0026#34;); // Convert Name to Description final Description d2 = Description.valueOf(n1); // Equality is based on the underlying Boolean value. System.out.println(\u0026#34;n1.equal(d1) : \u0026#34; + n1.equals(d1)); System.out.println(\u0026#34;d1.equal(d2) : \u0026#34; + d1.equals(d2)); result:\nn1.equal(d1) : true d1.equal(d2) : true  "
},
{
	"uri": "http://vankessel-it.io/real_doc/domain/valuetype/time/",
	"title": "Time",
	"tags": [],
	"description": "",
	"content": " Java Time Value Types extend DomainTime, which is a wrapper arround a LocalTime instance. The constructor requires a meta-object MTime to specify the precision: minutes, seconds or milliseconds.\nThe Time value-type class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;plusSecondes\u0026rsquo; and \u0026lsquo;minusMinutes\u0026rsquo;.\nFor example, the declaration of a new StartTime type:\nclass StartTime extends DomainTime\u0026lt;StartTime\u0026gt;{ public StartTime(final LocalTime value) { super(MTime.create(MTimePrecision.MINUTES), value); } @Override protected StartTime createInstance(final LocalTime value) { return new StartTime(value); } } usage:\nfinal StartTime d1 = new StartTime(LocalTime.now()); final StartTime d2 = d1.plusMinutes(5); final StartTime d3 = d1.minusHours(5); final StartTime d4 = d1.plusSeconds(10); final StartTime d5 = d1.minusSeconds(20); System.out.println(\u0026#34;d1 : \u0026#34; +d1); System.out.println(\u0026#34;d1.plusMinutes(5) : \u0026#34; +d2); System.out.println(\u0026#34;d1.minusHours(5) : \u0026#34; +d3); System.out.println(\u0026#34;d1.plusSeconds(20) : \u0026#34; +d4); System.out.println(\u0026#34;d1.minusSeconds(20): \u0026#34; +d5); System.out.println(\u0026#34;d2.isBefore(d1) : \u0026#34; +d2.isBefore(d1)); System.out.println(\u0026#34;d2.isAfter(d1) : \u0026#34; +d2.isAfter(d1)); System.out.println(\u0026#34;d1.equals(d4) : \u0026#34; +d1.equals(d4)); System.out.println(\u0026#34;d1.equals(d5) : \u0026#34; +d1.equals(d5)); result:\nd1 : 19:34 d1.plusMinutes(5) : 19:39 d1.minusHours(5) : 14:34 d1.plusSeconds(20) : 19:34 d1.minusSeconds(20): 19:33 d2.isBefore(d1) : false d2.isAfter(d1) : true d1.equals(d4) : true d1.equals(d5) : false  Notice that the results of plusSeconds() and minusSeconds() are truncated to minutes according to the precision of StartTime.\n DSL Time value types can be also be created using the REAL DSL:\nimport nl.openframe.erp.system.sr.SYS_SRLabels.batchTimeLabel time BatchTime batchTimeLabel minutes  This will generate two new classes: BatchTime.java and AbstractBatchTime.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class BatchTime extends AbstractBatchTime{ public BatchTime(final LocalTime value) { super(value); } } The abstract class extends DomainTime and adds several new static constructors:\nfinal BatchTime d1 = BatchTime.now(); final BatchTime d2 = BatchTime.valueOf(LocalTime.now()); final BatchTime d3 = BatchTime.valueOf(\u0026#34;13:45\u0026#34;); final BatchTime d4 = BatchTime.valueOf(d3.minusMinutes(10)); System.out.println(\u0026#34;d1 : \u0026#34; + d1); System.out.println(\u0026#34;d2 : \u0026#34; + d2); System.out.println(\u0026#34;d3 : \u0026#34; + d3); System.out.println(\u0026#34;d4 : \u0026#34; + d4); System.out.println(\u0026#34;d1.equals(d2) : \u0026#34; + d1.equals(d2)); System.out.println(\u0026#34;d1.equals(d3) : \u0026#34; + d1.equals(d3)); result:\nd1 : 19:37 d2 : 19:37 d3 : 13:45 d4 : 13:35 d1.equals(d2) : true d1.equals(d3) : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/",
	"title": "REAL ERP",
	"tags": [],
	"description": "",
	"content": " REAL Documentation REAL Documentation is created with Hugo and Hugo-theme-learn, a fast and modern static website engine written in Go.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it\nYour modification will be deployed automatically when merged.\n Automatically published and hosted thanks to Netlify. Read more about Automated HUGO deployments with Netlify\n -- "
},
{
	"uri": "http://vankessel-it.io/real_doc/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]