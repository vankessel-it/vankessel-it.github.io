[
{
	"uri": "http://vankessel-it.io/real_doc/reference/labels/",
	"title": "Labels",
	"tags": [],
	"description": "",
	"content": " Labels enable the internationalization (i18n) of the user-interface. All user-facing text is replaced by label-codes. These codes are grouped together into label-sets, and translated using the standard Java i18n property-files.\nFor example, DSL declaration:\npackage nl.openframe.erp.system.bt labelSet SYS_BTLabels{ label timeStampLabel \u0026#34;Time Stamp\u0026#34; label emailLabel \u0026#34;Email\u0026#34; icon \u0026#34;EMAIL\u0026#34; label confirmedLabel \u0026#34;Confirmed\u0026#34; }  The label set has an identifier (SYS_BT_Labels), and every label has a code (confirmedLabel, etc.). Together with the package name, these comprise the fully qualified name of the label. The confirmedLabel, for example, is imported in the following Confirmed value type declaration:\npackage nl.openframe.erp.system.bt import nl.openframe.erp.system.bt.SYS_BTLabels.confirmedLabel boolean Confirmed confirmedLabel  Labels can optionally have a short name, an icon (Material Design Icons) and a style code. The style code is generally used for colors, for example:\nlabel alertStatusLabel1 \u0026#34;Bug\u0026#34; icon \u0026#34;BUG_REPORT\u0026#34; style \u0026#34;red\u0026#34; label alertStatusLabel2 \u0026#34;Error\u0026#34;\ticon \u0026#34;BUG_REPORT\u0026#34; style \u0026#34;red\u0026#34; label alertStatusLabel3 \u0026#34;Warning\u0026#34; icon \u0026#34;BUG_REPORT\u0026#34; style \u0026#34;orange\u0026#34; label alertStatusLabel4 \u0026#34;Info\u0026#34; icon \u0026#34;BUG_REPORT\u0026#34; style \u0026#34;blue\u0026#34; label alertStatusLabel5 \u0026#34;Solved\u0026#34; icon \u0026#34;BUG_REPORT\u0026#34; style \u0026#34;green\u0026#34;  Generated code Label-sets generate two source files:\n A .properties file with one or more entries per label, which can be translated according to standard Java practises.  timeStampLabel=Time Stamp emailLabel=Email emailLabel.icon=EMAIL confirmedLabel=Confirmed   A java class with a constant for every label name. This alows you to reference labels without the use of string literals.  package nl.openframe.erp.system.bt; public class SYS_BTLabels{ public static final String TIME_STAMP_LABEL = \u0026#34;timeStampLabel\u0026#34;; public static final String EMAIL_LABEL = \u0026#34;emailLabel\u0026#34;; public static final String CONFIRMED_LABEL = \u0026#34;confirmedLabel\u0026#34;; } Labels also have optional properties for \u0026lsquo;focus-icon\u0026rsquo; and \u0026lsquo;focus-style\u0026rsquo;, be these are currently not used.\n All labels are imported into the application, and for convenience reasons, they are referenced only by label name. This means that label names should be globally unique in order to avoid conflicts.\nThe generated files are located in the \u0026lsquo;generated\u0026rsquo; directory. They will be overwritten during every code-generation and should not be changed manually. The label-set should hold the default language text, for extra languages new \u0026lsquo;.properties\u0026rsquo; files should be added in the \u0026lsquo;manual\u0026rsquo; code directory.\n"
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/",
	"title": "Java Value types",
	"tags": [],
	"description": "",
	"content": "Value Types can be created by extending the base classes: DomainBoolean, DomainDate, DomainDateTime, DomainDecimal, DomainEnumerate, DomainInteger, DomainLong, DomainString, DomainText and DomainTime.\nNote that the Enumerate Value Type must be created using the DSL for the simple reason that Enumerates in Java do not support inheritance.\n Because value types objects are immutable they can benefit from caching (\u0026lsquo;flyweight\u0026rsquo; design-pattern). For this reason it is recommended to use static constructors in stead of the new keyword.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction REAL enables developers to focus on business functionality, while retaining the breadth and power of the Java eco-system.\n"
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/",
	"title": "Value Types",
	"tags": [],
	"description": "",
	"content": " Value Types are immutable objects that represent business concepts which have no identity of their own. They are identified by the object properties, the same as for instance a String object in Java. Examples of Value Types are Amount, Price, Quantity and Confirmed.\nValue Types wrap Java primitive types in order to provide additional abstraction and validation. The following value types are supported:\n Boolean Date DateTime Decimal Enumerate Integer Long String Text Time  Abstraction Value Types make business code more readable and concise. Consider, for example, the following createOrder method:\npublic SalesOrder createOrder( Document document, OrderDate orderDate, Customer customer, Reference customerReference, Item item, Quantity quantity, Price price) It is very specific regarding the input parameters. The caller has to provide a Document which will be defined as a string, of a specific length and without spaces. The Reference is a much longer string which does allow spaces. The OrderDate is defined to be different from an InvoiceDate. The Quantity has a smaller scale than Price. Et cetera\u0026hellip;\nCompare this with the same method without value type abstraction:\npublic SalesOrder createOrder( String document, LocalDate orderDate, Customer customer, String customerReference, Item item, BigDecimal quantity, BigDecimal price) Much of the semantics are lost. Even worse, this method allows the quantity and price to be mixed up. It accepts documents where a customer reference is expected, and there is no guarentee that the provided values do not exceed the field length of the database. Et cetera.\nValidation Only valid value-type instances can be created. Decimals are rounded upon creation to fit the precision and scale. String value types will throw an exception upon creation if they exceed the defined length. And, as value-types are classes, new validation logic can be added to the constructor.\nDeclaration The REAL DSL provides a convenient way to declare value types. Note that all value-types have a label, which is used as a default in entities and views. Examples of value-type declarations:\nboolean Confirmed confirmedLabel date ExecutionDate executionDateLabel datetime DataEntryDateTime dataEntryDateTimeLabel milliseconds decimal Amount amountLabel 10 2 half_up integer IPPort ipPortLabel 0 99999 long EventId eventIdLabel 0 999999999 string Description descriptionLabel 60 text Notes notesLabel time BatchTime batchTimeLabel minutes  The declaration generates an abstract and a concrete class, both in the \u0026lsquo;generated\u0026rsquo; source folder. The abstract class extends a base value-type class (DomainBoolean, DomainString, etc.) and adds static constructors. The concrete class is just a skeleton that can be moved to the \u0026lsquo;manual\u0026rsquo; source folder and customized to add validation or functionality.\nclassDiagram DomainBoolean For more information regarding the base value types, see Appendix A.\nConventions The ValueType API makes a consistent use of method prefixes.\n of - static factory method get - gets the value of something is - checks if something is true  For example:\nfinal Amount a1 = Amount.of(123.45); final Amount a2 = Amount.of(\u0026#34;123.45\u0026#34;); final BigDecimal value = a1.getValue(); if(a1.isNegative()){}; final Confirmed c1 = Confirmed.of(true); final Confirmed c2 = Confirmed.of(\u0026#34;True\u0026#34;); if(c1.isFalse()){}; All value types implement the Comparable interface and provide a getValue() method to access the wrapped primitive value.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/entity/",
	"title": "Domain Entities",
	"tags": [],
	"description": "",
	"content": " Domain Entities are mutable objects that represent business concepts and are identified by a business key. Examples of Entities are SalesOrder, Item and TermsOfDelivery.\nAn entity contains a collection of fields, has a business-key and optionaly a number of search fields. Most Domain Entities are implemented as JPA Entities, but any class that implements the DomainEntity interface is valid.\nEntity Concepts:\n attribute: a value that conforms to a value type. relation: a reference to an other entity. field: either an attribute or a relation. Fields can be mandatory, calculated or transient. field-path: a sequence of one or more fields for navigating relations to other entities. business-key: the primary natural key of the entity, consisting of one or more field-paths. search-fields: one or more field-paths that provide default search functionality.  Take for example the User entity:\nentity User userLabel plural usersLabel { business-key loginCode search-fields userName attribute LoginCode loginCode mandatory attribute Name userName mandatory relation UserType userType mandatory attribute Notes userNotes attribute RecordStatus recordStatus default \u0026#34;10\u0026#34; calculated }  The User entity has five fields, the natural key is loginCode. The userName searchfield allows easy searching for users when selecting users. All fields are mandatory, except for the userNotes text field.\nNullability The following fields are never null:\n Boolean Decimal Enumerate Integer String  The following field can have value null:\n Date DateTime Time Text Any relation to other entities  Validation REAL ensures that only valid entities can be created:\n all mandatory fields and the business-key fields are part of the constructor setters of mandatory fields do not allow null-values  This is supported by the Nullabilty annotations: constructor parameters and all entity \u0026lsquo;getters\u0026rsquo; and \u0026lsquo;setters\u0026rsquo; are annotated with either @Nullable or @NonNull.\nThe concete User class has the following constructor:\npublic User( @NonNull final LoginCode loginCode, @NonNull final UserType userType, @NonNull final Name userName) { super(loginCode, userType, userName); } It includes all fields except userNotes as these are not mandatory. The benefit of this approach is compile-time validation.\nUserType userType = user.getUserType(); userType.getDescription(); There is no need to check if userType is null, before calling a method on the object. The compiler knows that getUserType() can not return a null value. The following code however will generate a compile time error 1:\nUserNotes userNotes = user.getUserNotes(); userNotes.getLength(); Every entity has a validate() method that is called before persisting or updating the entity. The validate method can be extended in the concrete class. By default it checks that mandatory String value-types can not be empty, or contain only spaces. Mandatory Integer or Long value-types can not be 0.\nNote that entities can also have a transient option. This will remove all server side persistence code.\nField options Mandatory fields:\n are included in the constructed, except when they are defined as calculated, transient or have a default value. have non-null JPA field-annotations must be non-null in constructor and setters (check by IDE) strings can not be empty or contain only spaces in the constructor or when persisting to database integers and longs can not have value 0 in the constructor or when persisting to database will not return null in getters (check by IDE)  Calculated fields\n have a setter with prefix \u0026lsquo;__\u0026rsquo; to indicate that it is primarily an internal derived field and external code should use the setter with care.  Transient fields\n have JPA annotation @Transient  should be NonNull by default (using the package-info.java class).\n Note that the IDE has to be configured for Nullability checks. And all packages [return]   "
},
{
	"uri": "http://vankessel-it.io/real_doc/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/how-to/",
	"title": "How-to",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " Global application configurations are contained in one or more configuration DSL files.\nLabels The configuration file specifies the label-sets available in the application:\npackage nl.openframe.erp.system import nl.openframe.erp.system.bc.SYS_BCLabels import nl.openframe.erp.system.bf.SYS_BFLabels import nl.openframe.erp.system.bt.SYS_BTLabels import nl.openframe.erp.system.sr.SYS_SRLabels import nl.openframe.erp.system.SystemLabels configuration SystemSharedConfiguration{ label-set SYS_BCLabels label-set SYS_BFLabels label-set SYS_BTLabels label-set SYS_SRLabels label-set SystemLabels }  This translates into a Spring configuration class which imports all the message resources.\n@Configuration public class SystemSharedConfiguration{ @Bean public MessageSource messageSource() { final ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasenames( \u0026#34;classpath:/nl/openframe/erp/system/bc/SYS_BCLabels\u0026#34;, \u0026#34;classpath:/nl/openframe/erp/system/bf/SYS_BFLabels\u0026#34;, \u0026#34;classpath:/nl/openframe/erp/system/bt/SYS_BTLabels\u0026#34;, \u0026#34;classpath:/nl/openframe/erp/system/sr/SYS_SRLabels\u0026#34;, \u0026#34;classpath:/nl/openframe/erp/system/SystemLabels\u0026#34; ); messageSource.setDefaultEncoding(\u0026#34;UTF-8\u0026#34;); return messageSource; } }"
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/",
	"title": "Appendix",
	"tags": [],
	"description": "",
	"content": " Appendix "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/boolean/",
	"title": "Boolean",
	"tags": [],
	"description": "",
	"content": "Boolean value type DSL declaration:\nimport nl.openframe.erp.system.SystemLabels.confirmedLabel boolean Confirmed confirmedLabel  This will generate two new classes: Confirmed.java and AbstractConfirmed.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class Confirmed extends AbstractConfirmed{ public Confirmed(final Boolean value) { super(value); } } The abstract class extends DomainBoolean and adds static constructors:\nfinal Confirmed c1 = Confirmed.of(true); final Confirmed c2 = Confirmed.of(\u0026#34;True\u0026#34;); final Confirmed c3 = Confirmed.of(\u0026#34;T\u0026#34;); // Equality is based on the underlying Boolean value. System.out.println(\u0026#34;c1.equal(c2) : \u0026#34; + c1.equals(c2)); System.out.println(\u0026#34;c1.equal(c3) : \u0026#34; + c1.equals(c3)); result:\nc1.equal(c2) : true c1.equal(c3) : true  See Domain Boolean for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/date/",
	"title": "Date",
	"tags": [],
	"description": "",
	"content": "Date value type DSL declaration:\nimport nl.openframe.erp.system.bt.SYS_BTLabels.executionDateLabel date ExecutionDate executionDateLabel  This will generate two new classes: ExecutionDate.java and AbstractExecutionDate.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class ExecutionDate extends AbstractExecutionDate{ public ExecutionDate(final LocalDate value) { super(value); } } The abstract class extends DomainDate and adds static constructors:\nfinal ExecutionDate d1 = ExecutionDate.now(); final ExecutionDate d2 = ExecutionDate.of(LocalDate.now()); final ExecutionDate d3 = ExecutionDate.of(\u0026#34;01-01-2019\u0026#34;); final ExecutionDate d4 = ExecutionDate.of(d3.minusDays(1)); System.out.println(\u0026#34;d1 : \u0026#34; + d1); System.out.println(\u0026#34;d2 : \u0026#34; + d2); System.out.println(\u0026#34;d3 : \u0026#34; + d3); System.out.println(\u0026#34;d4 : \u0026#34; + d4); System.out.println(\u0026#34;d1.equals(d2) : \u0026#34; + d1.equals(d2)); System.out.println(\u0026#34;d1.equals(d3) : \u0026#34; + d1.equals(d3)); result:\nd1 : 22-08-2019 d2 : 22-08-2019 d3 : 01-01-2019 d4 : 31-12-2018 d1.equals(d2) : true d1.equals(d3) : false  See Domain Date for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/datetime/",
	"title": "DateTime",
	"tags": [],
	"description": "",
	"content": "DateTime value type DSL declaration, including precision:\nimport nl.openframe.erp.system.sr.SYS_SRLabels.alertDateTimeLabel datetime AlertDateTime alertDateTimeLabel milliseconds  The precision can be milliseconds, seconds or minutes. New instances will be truncated according to their precision.\nThis will generate two new classes: AlertDateTime.java and AbstractAlertDateTime.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class AlertDateTime extends AbstractAlertDateTime{ public AlertDateTime(final LocalDateTime value) { super(value); } } The abstract class extends DomainDateTime and adds static constructors:\nfinal AlertDateTime d1 = AlertDateTime.now(); final AlertDateTime d2 = AlertDateTime.of(LocalDateTime.now()); final AlertDateTime d3 = AlertDateTime.of(\u0026#34;01-01-2019\u0026#34;); final AlertDateTime d4 = AlertDateTime.of(d3.minusDays(1)); System.out.println(\u0026#34;d1 : \u0026#34; + d1); System.out.println(\u0026#34;d2 : \u0026#34; + d2); System.out.println(\u0026#34;d3 : \u0026#34; + d3); System.out.println(\u0026#34;d4 : \u0026#34; + d4); System.out.println(\u0026#34;d1.equals(d2) : \u0026#34; + d1.equals(d2)); System.out.println(\u0026#34;d1.equals(d3) : \u0026#34; + d1.equals(d3)); result:\nd1 : 22-08-2019 16:45:45.381191000 d2 : 22-08-2019 16:45:45.382224000 d3 : 01-01-2019 08:00:00.00 d4 : 31-12-2018 08:00:00.00 d1.equals(d2) : false d1.equals(d3) : false  See Domain DateTime for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/decimal/",
	"title": "Decimal",
	"tags": [],
	"description": "",
	"content": "Decimal value type DSL declaration, including respectively, the precision, scale and rounding:\nimport nl.openframe.erp.system.SystemLabels.amountLabel decimal Amount amountLabel 10 2 half_up  The rounding can be ceiling, down, floor, half_down, half_even, half_up or up.\nThis will generate two new classes: Amount.java and AbstractAmount.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class Amount extends AbstractAmount{ public Amount(final BigDecimal value) { super(value); } } The abstract class extends DomainDecimal and adds static constructors:\n// Create new instance final Amount a1 = Amount.of(new BigDecimal(\u0026#34;123.45\u0026#34;)); final Amount a2 = Amount.of(123.45); final Amount a3 = Amount.of(\u0026#34;123.45\u0026#34;); // Convert Amount to Price final Price p1 = Price.of(a1); See Domain Decimal for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": " Technical Principles  business-code independant of REAL separation of business-logic and UI-technology user interaction logic must be UI-independant and server-side auto-generated UI, but full-manual option available all code and domain-structures in one GIT repository Nullability checks throughout all code Only valid business objects can be instantiated (all mandatory fields must be set, call to validate() generates no errors)  A set of 13 libraries "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/boolean/",
	"title": "Domain Boolean",
	"tags": [],
	"description": "",
	"content": "Boolean Value Types extend DomainBoolean, which is a wrapper arround a Boolean instance.\nThe value-type must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;negate\u0026rsquo;.\nFor example, the declaration of a new Confirmed value type:\nclass Confirmed extends DomainBoolean\u0026lt;Confirmed\u0026gt;{ public Confirmed(final Boolean value) { super(value); } @Override protected Confirmed createInstance(final Boolean value) { return new Confirmed(value); } } usage:\nfinal Confirmed confirmed = new Confirmed(false); System.out.println(\u0026#34;negate : \u0026#34; +confirmed.negate()); System.out.println(\u0026#34;is-false : \u0026#34; +confirmed.isFalse()); System.out.println(\u0026#34;is-true : \u0026#34; +confirmed.isTrue()); result:\nnegate : true is-false : true is-true : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/date/",
	"title": "Domain Date",
	"tags": [],
	"description": "",
	"content": "Date Value Types extend DomainDate, which is a wrapper arround a LocalDate instance.\nThe Date value-type class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;plusDays\u0026rsquo; and \u0026lsquo;minusDays\u0026rsquo;.\nFor example, the declaration of a new InvoiceDate type:\nclass InvoiceDate extends DomainDate\u0026lt;InvoiceDate\u0026gt;{ public InvoiceDate(final LocalDate value) { super(value); } @Override protected InvoiceDate createInstance(final LocalDate value) { return new InvoiceDate(value); } } usage:\nfinal InvoiceDate d1 = new InvoiceDate(LocalDate.now()); final InvoiceDate d2 = d1.plusDays(5); final InvoiceDate d3 = d1.minusDays(5); System.out.println(\u0026#34;d1.plusDays(5) : \u0026#34; +d2); System.out.println(\u0026#34;d1.minusDays(5): \u0026#34; +d3); System.out.println(\u0026#34;d2.isBefore(d1): \u0026#34; +d2.isBefore(d1)); System.out.println(\u0026#34;d2.isAfter(d1) : \u0026#34; +d2.isAfter(d1)); System.out.println(\u0026#34;d2.equals(d1) : \u0026#34; +d2.equals(d1)); result:\nd1.plusDays(5) : 2019-08-27 d1.minusDays(5): 2019-08-17 d2.isBefore(d1): false d2.isAfter(d1) : true d2.equals(d1) : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/datetime/",
	"title": "Domain DateTime",
	"tags": [],
	"description": "",
	"content": "DateTime Value Types extend DomainDateTime, which is a wrapper arround a LocalDateTime instance. The constructor requires a meta-object MDateTime to specify the precision: minutes, seconds or milliseconds.\nThe DateTime value-type class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;plusDays\u0026rsquo; and \u0026lsquo;minusDays\u0026rsquo;.\nFor example, the declaration of a new TimeStamp type:\nclass TimeStamp extends DomainDateTime\u0026lt;TimeStamp\u0026gt;{ public TimeStamp(final LocalDateTime value) { super(MDateTime.create(MTimePrecision.MINUTES), value); } @Override protected TimeStamp createInstance(final LocalDateTime value) { return new TimeStamp(value); } } usage:\nfinal TimeStamp d1 = new TimeStamp(LocalDateTime.now()); final TimeStamp d2 = d1.plusMinutes(5); final TimeStamp d3 = d1.minusHours(5); final TimeStamp d4 = d1.plusSeconds(10); final TimeStamp d5 = d1.minusSeconds(20); System.out.println(\u0026#34;d1 : \u0026#34; +d1); System.out.println(\u0026#34;d1.plusMinutes(5) : \u0026#34; +d2); System.out.println(\u0026#34;d1.minusHours(5) : \u0026#34; +d3); System.out.println(\u0026#34;d1.plusSeconds(20) : \u0026#34; +d4); System.out.println(\u0026#34;d1.minusSeconds(20): \u0026#34; +d5); System.out.println(\u0026#34;d2.isBefore(d1) : \u0026#34; +d2.isBefore(d1)); System.out.println(\u0026#34;d2.isAfter(d1) : \u0026#34; +d2.isAfter(d1)); System.out.println(\u0026#34;d1.equals(d4) : \u0026#34; +d1.equals(d4)); System.out.println(\u0026#34;d1.equals(d5) : \u0026#34; +d1.equals(d5)); result:\nd1 : 2019-08-22T16:23 d1.plusMinutes(5) : 2019-08-22T16:28 d1.minusHours(5) : 2019-08-22T11:23 d1.plusSeconds(20) : 2019-08-22T16:23 d1.minusSeconds(20): 2019-08-22T16:22 d2.isBefore(d1) : false d2.isAfter(d1) : true d1.equals(d4) : true d1.equals(d5) : false  Notice that the results of plusSeconds() and minusSeconds() are truncated to minutes according to the precision of TimeStamp.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/decimal/",
	"title": "Domain Decimal",
	"tags": [],
	"description": "",
	"content": " Decimal Value Types extend DomainDecimal, which is a wrapper arround a BigDecimal instance. The constructor requires a meta-object MDecimal to specify precision, scale and rounding.\nThe decimal value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;add\u0026rsquo;, \u0026lsquo;subtract\u0026rsquo;, etc.\nFor example, the declaration of a new Amount value type with a precision of five digits, and a scale of two:\npublic class Amount extends DomainDecimal\u0026lt;Amount\u0026gt; { public Amount(final BigDecimal value) { super(MDecimal.create(5, 2, MRounding.HALF_UP), value); } @Override protected Amount createInstance(final BigDecimal value) { return new Amount(value); } } Scale Domain decimals are rounded upon creation to ensure that no invalid objects can exist.\nSystem.out.println(\u0026#34;Scale:\u0026#34;); System.out.println(\u0026#34;- increase from 0 to 0.00 : \u0026#34; + new Amount(BigDecimal.ZERO)); System.out.println(\u0026#34;- increase from 1 to 1.00 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1\u0026#34;))); System.out.println(\u0026#34;- increase from 1.2 to 1.20 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.2\u0026#34;))); System.out.println(\u0026#34;- valid amount 1.23 : \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.23\u0026#34;))); System.out.println(\u0026#34;- round down from 1.233 to 1.23: \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.233\u0026#34;))); System.out.println(\u0026#34;- round up from 1.237 to 1.24: \u0026#34; + new Amount(new BigDecimal(\u0026#34;1.237\u0026#34;))); result:\nScale: - increase from 0 to 0.00 : 0.00 - increase from 1 to 1.00 : 1.00 - increase from 1.2 to 1.20 : 1.20 - valid amount 1.23 : 1.23 - round down from 1.233 to 1.23: 1.23 - round up from 1.237 to 1.24: 1.24  Precision System.out.println(\u0026quot;Decrease precision:\u0026quot;); System.out.println(\u0026quot;- from 12345.67 to 12346.00: \u0026quot; + new Amount(new BigDecimal(\u0026quot;12345.67\u0026quot;))); System.out.println(\u0026quot;- from 123456789 to 123460000.00: \u0026quot; + new Amount(new BigDecimal(\u0026quot;123456789\u0026quot;)));  result:\nDecrease precision: - from 12345.67 to 12346.00: 12346.00 - from 123456789 to 123460000.00: 123460000.00  Usage REAL will generate Value Type classes with many extra methods and constructors, but for this example we will add some of these methods manually.\nFirst a new constructor for Amount to create new instances based on other decimals:\npublic Amount(final DomainDecimal\u0026lt;?\u0026gt; value) { this(value.getValue()); } and two new Decimal types, Quantity:\nclass Quantity extends DomainDecimal\u0026lt;Quantity\u0026gt; { public Quantity(final BigDecimal value) { super(MDecimal.create(5, 2, MRounding.HALF_UP), value); } @Override protected Quantity createInstance(final BigDecimal value) { return new Quantity(value); } } and Price:\nclass Price extends DomainDecimal\u0026lt;Price\u0026gt; { public Price(final BigDecimal value) { super(MDecimal.create(5, 3, MRounding.HALF_UP), value); } @Override protected Price createInstance(final BigDecimal value) { return new Price(value); } public Amount multiply(final Quantity quantity) { return new Amount(super.multiply(quantity)); } } Value Types are plain java classes and can be extended with extra functionality, like the multiply method in the Price class. This method takes a quantity, multiplies it with the price and returns an amount using the new amount-constructor.\nGiven these new value types, calculations are possible using only the business concepts Amount, Price and Quantity:\nfinal Price price = new Price(new BigDecimal(\u0026#34;13.3329\u0026#34;)); final Quantity quantity = new Quantity(new BigDecimal(\u0026#34;3.50\u0026#34;)); final Amount amount = price.multiply(quantity); System.out.println(\u0026#34;Price \u0026#34;+price); System.out.println(\u0026#34;Quantity * \u0026#34;+quantity); System.out.println(\u0026#34;Amount = \u0026#34;+amount); result:\nPrice 13.333 Quantity * 3.50 Amount = 46.67  It is important to notice that two roundings were applied. The price is rounded to 13.333 before calculation. And after multiplication the result is rounded from 46.6655 to 46.67.\nAutomatic rounding must be used with care as a loss of precision can result in imprecise results.\n Validation Value Types can be validated by adding checks in the constructor. For example, disallow negative prices:\npublic Price(final BigDecimal value) { super(MDecimal.create(5, 3, MRounding.HALF_UP), value); if(isNegative()) { throw DomainValueException.create(\u0026#34;Negative price not allowed: \u0026#34;+this); } } This will cause an exception in all business logic whenever a negative price is created.\nnew Price(new BigDecimal(\u0026#34;-3.59\u0026#34;)); result:\nnl.openframe.domain.value.DomainValueException: Negative price not allowed: -3.590  Convenience methods Besides the standard methods add, substract, multiply, divide, max and min, domain decimals include additional convenience methods:\nfinal Amount amount = new Amount(new BigDecimal(\u0026#34;1.23\u0026#34;)); System.out.println(\u0026#34;absolute : \u0026#34;+ amount.absolute()); System.out.println(\u0026#34;negate : \u0026#34;+ amount.negate()); System.out.println(\u0026#34;is-negative : \u0026#34;+ amount.isNegative()); System.out.println(\u0026#34;is-positive : \u0026#34;+ amount.isPositive()); System.out.println(\u0026#34;is-zero : \u0026#34;+ amount.isZero()); System.out.println(\u0026#34;is-non-zero : \u0026#34;+ amount.isNonZero()); System.out.println(\u0026#34;is-one : \u0026#34;+ amount.isOne()); System.out.println(\u0026#34;is-minus one: \u0026#34;+ amount.isNegativeOne()); result:\nabsolute : 1.23 negate : -1.23 is-negative : false is-positive : true is-zero : false is-non-zero : true is-one : false is-minus one: false  Equality Domain Decimal equality is based on the underlying BigDecimal value.\nSystem.out.println(\u0026quot;a1.equal(a2) : \u0026quot; + a1.equals(a2)); System.out.println(\u0026quot;a1.equal(a3) : \u0026quot; + a1.equals(a3));  result:\na1.equal(a2) : true a1.equal(a3) : true  Only values with the same precision and scale can be equal.\n// Price and Amount have different scales System.out.println(\u0026quot;p1.equal(a1) : \u0026quot; + p1.equals(a1));  result:\np1.equal(a1) : false  "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/integer/",
	"title": "Domain Integer / Long",
	"tags": [],
	"description": "",
	"content": " Note: Value type DomainLong is not described here as it works the same as DomainInteger, except for the larger number range.\n Integer Value Types extend DomainInteger, which is a wrapper arround a Integer instance. The constructor requires a meta-object MInteger to specify lower- and upper-limit.\nThe integer value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;append\u0026rsquo;.\nFor example, the declaration of a new PortNumber value type with a range of [0,65535].\nclass PortNumber extends DomainInteger\u0026lt;PortNumber\u0026gt;{ public PortNumber(final Integer value) { super(MInteger.create(0, 65535), value); } @Override protected PortNumber createInstance(final Integer value) { return new PortNumber(value); } } usage:\nfinal PortNumber d1 = new PortNumber(80); final PortNumber d2 = new PortNumber(8000); final PortNumber d3 = d1.add(d2); System.out.println(\u0026#34;d1 : \u0026#34; +d1); System.out.println(\u0026#34;d2 : \u0026#34; +d2); System.out.println(\u0026#34;d3 : \u0026#34; +d3); System.out.println(\u0026#34;d1.isNegative() : \u0026#34; +d1.isNegative()); System.out.println(\u0026#34;d1.isZero() : \u0026#34; +d1.isZero()); result:\nd1 : 80 d2 : 8000 d3 : 8080 d1.isNegative() : false d1.isZero() : false  Note that an exception is thrown if the value is not within the declared range:\nnew PortNumber(-1); result:\nDomainValueException: Value -1 exceeds minimum value 0.  calculations:\nfinal PortNumber n1 = new PortNumber(1); final PortNumber n2 = new PortNumber(15); final PortNumber n3 = new PortNumber(4); System.out.println(\u0026#34;n1 : \u0026#34; + n1); System.out.println(\u0026#34;n2 : \u0026#34; + n2); System.out.println(\u0026#34;n3 : \u0026#34; + n3); System.out.println(\u0026#34;n2.divide(n3) : \u0026#34;+ n2.divide(n3)); System.out.println(\u0026#34;n2.multiply(n3): \u0026#34;+ n2.multiply(n3)); System.out.println(\u0026#34;n1.isOne() : \u0026#34;+ n1.isOne()); result:\nn1 : 1 n2 : 15 n3 : 4 n2.divide(n3) : 3 n2.multiply(n3): 60 n1.isOne() : true  Notice that the results of divide() is truncated to an integer value.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/string/",
	"title": "Domain String / Text",
	"tags": [],
	"description": "",
	"content": " Note: Value type DomainText is not described here as it works the same as DomainString, except for the limitless text length.\n String Value Types extend DomainString, which is a wrapper arround a String instance. The constructor requires a meta-object MString to specify length and case.\nThe string value-type-class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;append\u0026rsquo;.\nFor example, the declaration of a new Description value type with a lenght of 60 characters.\nclass Description extends DomainString\u0026lt;Description\u0026gt;{ public Description(final String value) { super(MString.create(60, false), value); } @Override protected Description createInstance(final String value) { return new Description(value); } } usage:\nfinal Description d1 = new Description(\u0026#34;abcdefg\u0026#34;); System.out.println(\u0026#34;d1.append(\u0026#39;_hij\u0026#39;): \u0026#34; +d1.append(\u0026#34;_hij\u0026#34;)); System.out.println(\u0026#34;getLeft(3) : \u0026#34; +d1.getLeft(3)); System.out.println(\u0026#34;isEmpty() : \u0026#34; +d1.isEmpty()); System.out.println(\u0026#34;isNotEmpty() : \u0026#34; +d1.isNotEmpty()); result:\nd1.append('_hij'): abcdefg_hij getLeft(3) : abc isEmpty() : false isNotEmpty() : true  Note that strings are not automatically truncated, if they do not fit the domain, an exception will be thrown:\nnew Description(\u0026#34;abcdefg\u0026#34;.repeat(30)); result:\nDomainValueException: Value exceeds 60 characters.  Equality // Equality is based on the underlying Boolean value. final Name n1 = new Name(\u0026#34;abcdef\u0026#34;); final Description d1 = new Description(\u0026#34;abcdef\u0026#34;); System.out.println(\u0026#34;n1.equal(d1) : \u0026#34; + n1.equals(d1)); System.out.println(\u0026#34;d1.equal(d2) : \u0026#34; + d1.equals(d2)); result:\nn1.equal(d1) : true d1.equal(d2) : true  "
},
{
	"uri": "http://vankessel-it.io/real_doc/appendix/domain_valuetypes/time/",
	"title": "Domain Time",
	"tags": [],
	"description": "",
	"content": "Time Value Types extend DomainTime, which is a wrapper arround a LocalTime instance. The constructor requires a meta-object MTime to specify the precision: minutes, seconds or milliseconds.\nThe Time value-type class must implement at least one method; createInstance(). This method allows the return of typed objects after operations as \u0026lsquo;plusSecondes\u0026rsquo; and \u0026lsquo;minusMinutes\u0026rsquo;.\nFor example, the declaration of a new StartTime type:\nclass StartTime extends DomainTime\u0026lt;StartTime\u0026gt;{ public StartTime(final LocalTime value) { super(MTime.create(MTimePrecision.MINUTES), value); } @Override protected StartTime createInstance(final LocalTime value) { return new StartTime(value); } } usage:\nfinal StartTime d1 = new StartTime(LocalTime.now()); final StartTime d2 = d1.plusMinutes(5); final StartTime d3 = d1.minusHours(5); final StartTime d4 = d1.plusSeconds(10); final StartTime d5 = d1.minusSeconds(20); System.out.println(\u0026#34;d1 : \u0026#34; +d1); System.out.println(\u0026#34;d1.plusMinutes(5) : \u0026#34; +d2); System.out.println(\u0026#34;d1.minusHours(5) : \u0026#34; +d3); System.out.println(\u0026#34;d1.plusSeconds(20) : \u0026#34; +d4); System.out.println(\u0026#34;d1.minusSeconds(20): \u0026#34; +d5); System.out.println(\u0026#34;d2.isBefore(d1) : \u0026#34; +d2.isBefore(d1)); System.out.println(\u0026#34;d2.isAfter(d1) : \u0026#34; +d2.isAfter(d1)); System.out.println(\u0026#34;d1.equals(d4) : \u0026#34; +d1.equals(d4)); System.out.println(\u0026#34;d1.equals(d5) : \u0026#34; +d1.equals(d5)); result:\nd1 : 19:34 d1.plusMinutes(5) : 19:39 d1.minusHours(5) : 14:34 d1.plusSeconds(20) : 19:34 d1.minusSeconds(20): 19:33 d2.isBefore(d1) : false d2.isAfter(d1) : true d1.equals(d4) : true d1.equals(d5) : false  Notice that the results of plusSeconds() and minusSeconds() are truncated to minutes according to the precision of StartTime.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/enumerate/",
	"title": "Enumerate",
	"tags": [],
	"description": "",
	"content": "The DSL declaration for an Enumerate value type with three options; \u0026lsquo;Yes\u0026rsquo;, \u0026lsquo;No\u0026rsquo;, \u0026lsquo;Unknown\u0026rsquo;:\nenumerate YesNoUnknown yesNoUnknownLabel{ Y: yesNoUnknownLabel_Y N: yesNoUnknownLabel_N U: yesNoUnknownLabel_U }  The labels are defined as follows:\nlabelSet SystemLabels{ label yesNoUnknownLabel \u0026#34;Yes/No/Unknown\u0026#34; label yesNoUnknownLabel_Y \u0026#34;Yes\u0026#34; label yesNoUnknownLabel_N \u0026#34;No\u0026#34; label yesNoUnknownLabel_U \u0026#34;Uknown\u0026#34; }  This will generate one class: YesNoUnknown.java. This class can be extended with custom code, however, as enumerates do not support inheritance, any future changes in the DSL will have to be handled manually.\nThe enumerate implements DomainEnumerate and includes a static of constructor:\nfinal YesNoUnknown a1 = YesNoUnknown.YES; final YesNoUnknown a2 = YesNoUnknown.of(\u0026#34;Y\u0026#34;); final YesNoUnknown a3 = YesNoUnknown.of(\u0026#34;N\u0026#34;); System.out.println(\u0026#34;a1.getCode() : \u0026#34; + a1.getCode()); System.out.println(\u0026#34;a2.getCode() : \u0026#34; + a2.getCode()); System.out.println(\u0026#34;a3.getCode() : \u0026#34; + a3.getCode()); System.out.println(\u0026#34;a1.equals(a2) : \u0026#34; + a1.equals(a2)); System.out.println(\u0026#34;a1.equals(a3) : \u0026#34; + a1.equals(a3));\t result:\na1.getCode() : Y a2.getCode() : Y a3.getCode() : N a1.equals(a2) : true a1.equals(a3) : false  Note that the enumerate constants are the same as the label text. For example YesNoUnknown.UNKNOWN. The UNKNOWN is derived from the yesNoUnknownLabel_U label. The actual code stored in the database is U. Every enumerate item has a getCode() method to retrieve the database value.\nThis approach ensures that enumerates in source-code are expressive, while the code in the database can remain short. However, this also means that changes in label-text will require changes in the source-code.\n"
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/integer/",
	"title": "Integer",
	"tags": [],
	"description": "",
	"content": " Note: Value type Long is not described here as it works the same as Integer, except for the larger number range.\n Integer value type DSL declaration, including the lower- and upper-bound for values:\nimport nl.openframe.erp.system.sr.SYS_SRLabels.batchFrequencyLabel integer BatchFrequency batchFrequencyLabel 0 60  This will generate two new classes: BatchFrequency.java and AbstractBatchFrequency.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class BatchFrequency extends AbstractBatchFrequency{ public BatchFrequency(final Integer value) { super(value); } } The abstract class extends DomainInteger and adds static constructors:\nfinal BatchFrequency n1 = BatchFrequency.ONE; final BatchFrequency n2 = BatchFrequency.of(\u0026#34;1\u0026#34;); final BatchFrequency n3 = BatchFrequency.of(1); final BatchFrequency n4 = BatchFrequency.of(15); final BatchFrequency n5 = BatchFrequency.of(4); System.out.println(\u0026#34;n1 : \u0026#34; + n1); System.out.println(\u0026#34;n2 : \u0026#34; + n2); System.out.println(\u0026#34;n3 : \u0026#34; + n3); System.out.println(\u0026#34;n4 : \u0026#34; + n4); System.out.println(\u0026#34;n5 : \u0026#34; + n5); System.out.println(\u0026#34;n1.equals(n2) : \u0026#34;+ n1.equals(n2)); result:\nn1 : 1 n2 : 1 n3 : 1 n4 : 15 n5 : 4 n1.equals(n2) : true  See Domain Integer for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/comparison/",
	"title": "Product Comparison",
	"tags": [],
	"description": "",
	"content": " How does it stack up ? REAL is a low-code software development environment. REAL aims to minimize the overall code-base of administrative systems, while promoting concise and quality business-code.\n    Thinkwise Mendix Studio Pro 8 REAL 7     General      Technologie Platform MS .NET Java 11 Java 11   Product Type framework framework set libraries (13 in total)   Programming language procedural SQL nano/micro-flows, Java/JS call-outs Java for desktop, web (mobile) and server   Target audience Thinkwise developers Citizen developers Professional developers   Since 2002 2005 2007   # Developers 20+ 20+ 2+   Modelling      Database grafical-model grafical-model text-model (Domain Specific Language)   User-interface definition in tabels UI-designer, pages / widgets text-model (DSL), code or UI-designer (Vaadin)   Custom Code      Business code works only within Thinkwise works only within Mendix (micro-flow) independent from REAL, standard Java / Spring   User-interface code programming not supported works only within Mendix (nano-flow) dependent on REAL, standard Java / Spring   Uitbreidbaarheid very limited limited Java/JS call-out complete Java / Spring platform, and external libraries   Code Quality      Automatic checks no no industry-standard: Sonar, Structure101, etc.   Automated testing ? proprietary (unit-test microflow) industry-standard: JUnit, etc.   Value Types yes (limited) no yes, e.g. Amount, Price, Document, Quantity, etc.   Nullability checks no no yes, avoid the \u0026ldquo;billion dollar mistake\u0026rdquo; (Tony Hoare)   Tooling      Development environment proprietary proprietary industry-standard: Eclipse of IntelliJ   Versiebeheer proprietary, code and model separat proprietary, SVN extension (Team Server) industry-standard (GIT), datamodel and code    Deployment proprietary proprietary (Mendix server) industry-standard: Tomcat, JBoss, Websphere, etc.   Monitoring Database or IIS monitoring Java JMX Spring Boot Actuator and Java JMX   Continuity      # developers very limited limited 10.000.000 according to Oracle   Business-code dependend on Thinkwise dependend on Mendix dependend on Java (open source)   *Vendor lock-in 100% 100% user-interface limited, business-code no lock-in   Escrow available ? yes yes    "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/string/",
	"title": "String",
	"tags": [],
	"description": "",
	"content": " Note: Value type Text is not described here as it works the same as String, except for the limitless text length.\n String value type DSL declaration, including maximum number of characters:\nimport nl.openframe.erp.system.SystemLabels.descriptionLabel string Description descriptionLabel 60  This will generate two new classes: Description.java and AbstractDescription.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class Description extends AbstractDescription{ public Description(final String value) { super(value); } } The abstract class extends DomainString and adds static constructors:\nfinal Name n1 = Name.of(\u0026#34;abcdef\u0026#34;); final Description d1 = Description.of(\u0026#34;abcdef\u0026#34;); // Convert Name to Description final Description d2 = Description.of(n1); See Domain String for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/reference/dsl_valuetypes/time/",
	"title": "Time",
	"tags": [],
	"description": "",
	"content": "Time value type DSL declaration, including precision:\nimport nl.openframe.erp.system.sr.SYS_SRLabels.batchTimeLabel time BatchTime batchTimeLabel minutes  The precision can be milliseconds, seconds or minutes. New instances will be truncated according to their precision.\nThis will generate two new classes: BatchTime.java and AbstractBatchTime.java. The concrete class is a skeleton-class and can be used to add validation and additional functionality.\npublic class BatchTime extends AbstractBatchTime{ public BatchTime(final LocalTime value) { super(value); } } The abstract class extends DomainTime and adds static constructors:\nfinal BatchTime d1 = BatchTime.now(); final BatchTime d2 = BatchTime.of(LocalTime.now()); final BatchTime d3 = BatchTime.of(\u0026#34;13:45\u0026#34;); final BatchTime d4 = BatchTime.of(d3.minusMinutes(10)); System.out.println(\u0026#34;d1 : \u0026#34; + d1); System.out.println(\u0026#34;d2 : \u0026#34; + d2); System.out.println(\u0026#34;d3 : \u0026#34; + d3); System.out.println(\u0026#34;d4 : \u0026#34; + d4); System.out.println(\u0026#34;d1.equals(d2) : \u0026#34; + d1.equals(d2)); System.out.println(\u0026#34;d1.equals(d3) : \u0026#34; + d1.equals(d3)); result:\nd1 : 19:37 d2 : 19:37 d3 : 13:45 d4 : 13:35 d1.equals(d2) : true d1.equals(d3) : false  See Domain Time for more details.\n "
},
{
	"uri": "http://vankessel-it.io/real_doc/introduction/conventions/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/notes/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "REAL-business:\nresources: - goods - employees - packaging - tools - trucks / cars\nagents: - customers / suppliers - employees\nevents: - add resource - purchase goods - purchase tools\n rent-in resource\n enroll employee purchase services  rent-out resource\n sell services   remove resource\n fire employee sell goods sell tools  change resource\n use tools train employee  create resource\n assemble manufacture   Company (system dependency): - manages: currencies, units, languages, departments\nEmployee (system dependency): - manages: employee (user), authorizations, devices\nPartner: - depends on Employee - manages: partners, contacts, addresses\nAccounting: - depends on Partner\nItem: - manages: units - createItem(code, description)-\u0026gt;UUID\nInventory: - depends on Item, Partner - manages: units, locations\nOrder: - depends on Inventory, Accounting, Partner\nREAL: R: employee, materials, equipment E: receipt, delivery, payment A: employee, customer, supplier, freighter L: address, location\nR-SCS\nTeam (organizational) vs Box (physical, containerized). - add [Employee1] to [Team1] at date [x] - add [Employee2] to [Team2] at date [x] - add [Item001] to [BoxedItem002]\nA Sink can have negative Resources, e.g. Supplier. Every Event has planned / actual changes.\nUtilization: register use, e.g. km. hours. Consumption/Production: register increase/decrease, e.g. quantity\n********* Stock A StockResource is a Resource. Transport is an StockResource Event to change Location. Issue/Receipt is an StockResource Event to change Custodian. Rental is an StockResource Event to change Custodian and increase Consumption. Production is an StockResource Event to increase Consumption. Invoice is an StockResource Event to change Ownership.\nEquipment is a StockResource Material is StockResource\u0026lt;\u0026gt; Tool is a StockResource\n********* Packaging A PackagingResource is a Resource. Transport is an PackagingResource Event to change Location and increase Utilization. Delivery/Receipt is an PackagingResource Event to change Custodian. Invoice is an PackagingResource Event to change Ownership.\n********* HR A HumanResource is a Resource. A HumanResource can have an Employer (Manager). Work-Assignment is an HumanResource Event to change Location. Employment is an HumanResource Event to change Employment. TimeSheet is an HumanResource Event to increase Work.\n********** Vehicles A VehicleResource is a Resource. Trip is a VehicleResource to change Loation and increase Utilization. Rental is an VehicleResource Event to change Custodian. Sales/Purchase-Invoice is an VehicleResource Event to change Ownership.\nAgent is an owner/manipulator of Resources Event is a move of Resources both in Owner and Location Location is a container of Resources\nInvoice is an ownership move.\nStockUnit is a Resource Person is a Resource and an Agent Organization is an Agent Address is a Location\nOrganization has an initial Address Person has an initial Address\n********* Level 1 Person is discrete-unique - is a discrete-unique Person with unit Time[hrs]\nEquipment: - is a discrete-unique StockUnit with unit Quantity[pcs] - is grouped by EquipmentItem\nMaterial: - is a discrete StockUnit with unit Quantity[pcs] - is grouped by MaterialItem\nFluid: - is a non-discrete StockUnit with unit Volume[m3] - is grouped by FluidItem\nReceipt, Delivery, Invoice(Payment): - is an Event (actual)\nPerson/Organizaton-Move: - is an Event\nOrder: - is an Event (planned)\nAddress, Warehouse-location: - is a Location\n*********** Level 2 Employee: - is a Role of Person with start/end date\nSupplier, Customer, Freighter, Publisher: - is a Role of Organization with start/end date\nMaterial: - is categorized by Item - is a Resource with unit Quantity[Pieces, Liter, etc.]\nItem: - is organizational aggregation of Material - One Material can have ItemUnit can\nTeam: - is organizational aggregation of Person - is organized in Roles - EmployeeUnit can have one or more Roles within a Team\nContainer: - is physical aggregation of Item - is organized in LoadinSequences - Item can have one LoadingSequence within a Container\ncontext / command\ncompany: - create order - create transport-order\ntransport-order: - assign freighter - create item line - do/undo confirm order - do/undo loading\ntransport-item-line: - remove item-line - change item-line\norder : - change order - remove order - create order line - do/undo confirm order - create delivery - create invoice - print confirmation\norder-line: - remove order-line - change order-line\ndelivery: - do/undo confirm delivery - remove delivery\ndelivery-line: - change received quantities\nAll external information (user-entered data or from external system) must be versioned. - Sales Order -\u0026gt; Revisions\nOption 1: - SalesOrderRev table with all fields - SalesOrderRev table with same business key, command name and JSON object. - CommandSource table with entity name, command name and JSON object.\n Sales Order:\n workflow fields (confirmed, approved, etc.)  revisioned by confirmedCommand entity of type \u0026lsquo;Command\u0026rsquo;  auto fields: user, datetime defined field \u0026lsquo;confirmed\u0026rsquo;.   redundent totals fields redundent status fields  Equipment:\n    QueryDto\nReadDto find(\u0026hellip;)\nvoid persist(CommandDto dto)\nWriteDto afterInput(CommandDto dto)\nvoid delete(EntityKey key)\nvoid execute(EntityKey key, parameters)\n===================================================================================== - XDomains - XEntities - XEntitiesRevision\nPartner - UUID id (uuid-pk) - int version (jpa) - Code code (bk, mandatory) - Name name (mandatory) - Country country (uuid-fk) (mandatory, database reference)\nstatic Parter create(Code code, Name name, Country country){..}\nSession - UUID id (uuid-pk) - String user (mandatory) - DateTime created_timestamp (mandatory) - Optional processed_timestamp (optional) - Optional errorMessage (optional)\nRevision - UUID id (uuid-pk) - Session session (mandatory) - String entity_name (manatory) - UUID entity_id (optional) - XType type (insert, update, delete)\nPartnerRevision - Revision revision (uuid-fk, mandatory)\n EntityReference partner (optional) int partnerVersion (optional)\n Code code (optional)\n Name name (optional)\n EntityReference country (optional)\n  static PartnerRevision create(){..};\nNote: - revision tables can be archived at random without consequences.\nAdvantages - UUID: primary key does not change on persistence - Stateless implementation - History of user updates - History can be deleted at will - @NonNull on CURRENT-Class for mandatory values\nUI-starts session - client sends \u0026lsquo;start\u0026rsquo; to server and gets session-UUID.\nUI-create: - client sends \u0026lsquo;insert\u0026rsquo; with session-UUID and entity-name to server. The revision-UUID is returned. - client sends field values with revision-UUID - client sends \u0026lsquo;process\u0026rsquo; with session-UUID. Current-record is created with revision_create_UUID (important for references during update!)\nUI-update: - users selects \u0026lsquo;update\u0026rsquo; with session-UUID and current-UUID. The revision-UUID is returend. - client sends field values with revision-UUID - client sends \u0026lsquo;process\u0026rsquo; with revision-UUID. Current-record is updated.\nUI-delete: - client sends \u0026lsquo;delete\u0026rsquo; with session-UUID, entity-name and current-UUID to server. The revision-UUID is returend. - client sends \u0026lsquo;process\u0026rsquo; with revision-UUID. Current-record is removed.\n============================================= Server s = createSession() d1 = s.addDataSource(“Partner”) d2 = s.addDataSource(“Contact”)\nd1f = d1.addFilter(“partner.name like ‘c%’”) List\u0026lt;MKey\u0026gt; k1 = List\u0026lt;MKey\u0026gt; d1.getKeys () List\u0026lt;FField\u0026gt; d1fields = ...  Alternative 1 MMetaRecord rm1 = d1.getRecordMeta(d1fields)\nList\u0026lt;MRecord\u0026gt; r1 = d1.getRecords(k1, d1fields) d2f = d2.addFilter(“contact.partner = :partner”) d2f.setFilterParameter(“partner”, 100)  Alternative 2 MMetaField fm1 = d1.getFieldMeta(\u0026ldquo;code\u0026rdquo;)\nMFieldValue fv1 = d1.getFieldValue(k1[0],\u0026quot;code\u0026quot;) d2f = d2.addFilter(“contact.partner = :partner”) d2f.setFilterParameter(“partner”, 100)  ====================================== s = createSession() d1 = s.addDataSource(\u0026ldquo;Partner\u0026rdquo;) d1f = d1.addFilter(\u0026hellip;)\nd1.getRecordCount() d1.getRecord(0)  Server: stateless: Server.getKeyAndValues(\n"
},
{
	"uri": "http://vankessel-it.io/real_doc/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://vankessel-it.io/real_doc/",
	"title": "REAL ERP",
	"tags": [],
	"description": "",
	"content": " REAL Documentation REAL Documentation is created with Hugo and Hugo-theme-learn, a fast and modern static website engine written in Go.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it\nYour modification will be deployed automatically when merged.\n Automatically published and hosted thanks to Netlify. Read more about Automated HUGO deployments with Netlify\n -- "
},
{
	"uri": "http://vankessel-it.io/real_doc/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]